name: Regression Tests

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

env:
  SOLUTION_FILE_PATH: .
  BUILD_CONFIGURATION: Release

permissions:
  contents: read

jobs:
  regression-tests:
    name: Regression Tests
    runs-on: windows-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Add MSBuild to PATH
      uses: microsoft/setup-msbuild@v2

    - name: Restore NuGet packages
      working-directory: ${{env.GITHUB_WORKSPACE}}
      run: nuget restore ${{env.SOLUTION_FILE_PATH}}

    - name: Build Solution
      working-directory: ${{env.GITHUB_WORKSPACE}}
      run: msbuild /m /p:Configuration=${{env.BUILD_CONFIGURATION}} ${{env.SOLUTION_FILE_PATH}}

    - name: Verify Test Installer Output
      shell: pwsh
      run: |
        Write-Host "Checking for MSI files in TestJsonConfigInstaller build output"
        
        # Try multiple possible output paths (x64 platform may create different structure)
        $possiblePaths = @(
          "TestJsonConfigInstaller\bin\${{env.BUILD_CONFIGURATION}}",
          "TestJsonConfigInstaller\bin\${{env.BUILD_CONFIGURATION}}\x64",
          "TestJsonConfigInstaller\bin\x64\${{env.BUILD_CONFIGURATION}}"
        )
        
        $foundPath = $null
        foreach ($path in $possiblePaths) {
          if (Test-Path $path) {
            Write-Host "Found build output directory: $path"
            $foundPath = $path
            break
          }
        }
        
        if (-not $foundPath) {
          Write-Error "Build output directory not found in any expected location"
          Write-Host "Searched paths:"
          foreach ($path in $possiblePaths) {
            Write-Host "  - $path"
          }
          exit 1
        }
        
        # List all files for debugging
        Write-Host "Directory contents:"
        Get-ChildItem -Path $foundPath -Recurse | Select-Object FullName | Format-Table -AutoSize
        
        # Find the MSI file
        $msiFiles = Get-ChildItem -Path $foundPath -Filter "*.msi" -Recurse
        if ($msiFiles.Count -gt 0) {
          $msiPath = $msiFiles[0].FullName
          Write-Host "✓ Test installer built successfully: $msiPath"
          $fileInfo = Get-Item $msiPath
          Write-Host "  Size: $($fileInfo.Length) bytes"
          Write-Host "  Modified: $($fileInfo.LastWriteTime)"
        } else {
          Write-Error "✗ Test installer MSI not found in $foundPath"
          Write-Host "This may indicate the TestJsonConfigInstaller project did not build successfully."
          exit 1
        }

    - name: Upload Test Installer
      uses: actions/upload-artifact@v4
      with:
        name: test-installer
        path: |
          TestJsonConfigInstaller\bin\${{env.BUILD_CONFIGURATION}}\**\*.msi
          TestJsonConfigInstaller\bin\**\${{env.BUILD_CONFIGURATION}}\**\*.msi
        if-no-files-found: error

    - name: Test JSON Validation
      shell: pwsh
      run: |
        Write-Host "Testing JSON file validation..."
        
        # Test 1: Valid JSON file
        $validJson = @"
        {
          "ConnectionStrings": {
            "DefaultConnection": "Server=localhost;Database=Test;"
          },
          "Logging": {
            "LogLevel": {
              "Default": "Information"
            }
          }
        }
        "@
        
        $testFile = "test-valid.json"
        $validJson | Out-File -FilePath $testFile -Encoding UTF8
        
        try {
          $null = Get-Content $testFile | ConvertFrom-Json
          Write-Host "✓ Valid JSON test passed"
        } catch {
          Write-Error "✗ Valid JSON test failed: $_"
          exit 1
        }
        
        # Test 2: Invalid JSON file
        $invalidJson = '{ "key": "value" '
        $invalidFile = "test-invalid.json"
        $invalidJson | Out-File -FilePath $invalidFile -Encoding UTF8
        
        try {
          $null = Get-Content $invalidFile | ConvertFrom-Json
          Write-Error "✗ Invalid JSON test failed: Should have thrown an error"
          exit 1
        } catch {
          Write-Host "✓ Invalid JSON test passed: Error caught as expected"
        }
        
        # Test 3: Verify test JSON files exist
        $testJsonFiles = @(
          "TestJsonConfigInstaller\appsettings.json",
          "TestJsonConfigInstaller\appsettings.dotnet.json"
        )
        
        foreach ($file in $testJsonFiles) {
          if (Test-Path $file) {
            Write-Host "✓ Found: $file"
            try {
              $null = Get-Content $file | ConvertFrom-Json
              Write-Host "  - Valid JSON structure"
            } catch {
              Write-Error "  - Invalid JSON structure: $_"
              exit 1
            }
          } else {
            Write-Error "✗ Missing: $file"
            exit 1
          }
        }

    - name: Test Common .NET Patterns
      shell: pwsh
      run: |
        Write-Host "Testing common .NET configuration patterns..."
        
        # Create a test appsettings.json
        $testConfig = @"
        {
          "ConnectionStrings": {
            "DefaultConnection": "Server=localhost;Database=MyDb;"
          },
          "Logging": {
            "LogLevel": {
              "Default": "Information",
              "Microsoft": "Warning"
            }
          },
          "ApplicationSettings": {
            "DataPath": "C:\\ProgramData\\MyApp\\Data"
          }
        }
        "@
        
        $configFile = "test-config.json"
        $testConfig | Out-File -FilePath $configFile -Encoding UTF8
        
        # Parse and verify structure
        $config = Get-Content $configFile | ConvertFrom-Json
        
        # Test ConnectionStrings
        if ($config.ConnectionStrings.DefaultConnection) {
          Write-Host "✓ ConnectionStrings.DefaultConnection exists"
        } else {
          Write-Error "✗ ConnectionStrings.DefaultConnection not found"
          exit 1
        }
        
        # Test Logging
        if ($config.Logging.LogLevel.Default -eq "Information") {
          Write-Host "✓ Logging.LogLevel.Default is correct"
        } else {
          Write-Error "✗ Logging.LogLevel.Default is incorrect"
          exit 1
        }
        
        # Test Application Settings
        if ($config.ApplicationSettings.DataPath) {
          Write-Host "✓ ApplicationSettings.DataPath exists"
        } else {
          Write-Error "✗ ApplicationSettings.DataPath not found"
          exit 1
        }
        
        Write-Host "All common .NET pattern tests passed!"

    - name: Test JSONPath Patterns
      shell: pwsh
      run: |
        Write-Host "Testing JSONPath pattern scenarios..."
        
        # Create test JSON with nested arrays
        $complexJson = @"
        {
          "store": {
            "book": [
              {
                "category": "reference",
                "author": "Nigel Rees",
                "title": "Sayings of the Century",
                "price": 8.95
              },
              {
                "category": "fiction",
                "author": "Herman Melville",
                "title": "Moby Dick",
                "isbn": "0-553-21311-3",
                "price": 8.99
              }
            ]
          }
        }
        "@
        
        $jsonFile = "test-jsonpath.json"
        $complexJson | Out-File -FilePath $jsonFile -Encoding UTF8
        
        $data = Get-Content $jsonFile | ConvertFrom-Json
        
        # Test array access
        if ($data.store.book[0].title -eq "Sayings of the Century") {
          Write-Host "✓ Array access test passed"
        } else {
          Write-Error "✗ Array access test failed"
          exit 1
        }
        
        # Test nested property access
        if ($data.store.book[1].isbn -eq "0-553-21311-3") {
          Write-Host "✓ Nested property access test passed"
        } else {
          Write-Error "✗ Nested property access test failed"
          exit 1
        }
        
        Write-Host "All JSONPath pattern tests passed!"

    - name: Test distinctValues Action
      shell: pwsh
      run: |
        Write-Host "Testing distinctValues action..."
        
        # Create test JSON with duplicate values in arrays
        $jsonWithDuplicates = @"
        {
          "tags": ["production", "webapp", "production", "backend", "webapp", "api"],
          "features": {
            "enabled": ["feature1", "feature2", "feature1", "feature3"]
          },
          "settings": {
            "values": [1, 2, 3, 2, 4, 1, 5]
          }
        }
        "@
        
        $testFile = "test-duplicates.json"
        $jsonWithDuplicates | Out-File -FilePath $testFile -Encoding UTF8
        
        # Verify the test file has duplicates
        $data = Get-Content $testFile | ConvertFrom-Json
        
        # Test 1: Verify tags array has duplicates
        $uniqueTags = $data.tags | Select-Object -Unique
        if ($uniqueTags.Count -lt $data.tags.Count) {
          Write-Host "✓ Test data contains duplicate tags (expected)"
        } else {
          Write-Error "✗ Test data should contain duplicate tags"
          exit 1
        }
        
        # Test 2: Verify features.enabled array has duplicates
        $uniqueFeatures = $data.features.enabled | Select-Object -Unique
        if ($uniqueFeatures.Count -lt $data.features.enabled.Count) {
          Write-Host "✓ Test data contains duplicate features (expected)"
        } else {
          Write-Error "✗ Test data should contain duplicate features"
          exit 1
        }
        
        # Test 3: Verify numeric array has duplicates
        $uniqueValues = $data.settings.values | Select-Object -Unique
        if ($uniqueValues.Count -lt $data.settings.values.Count) {
          Write-Host "✓ Test data contains duplicate numeric values (expected)"
        } else {
          Write-Error "✗ Test data should contain duplicate numeric values"
          exit 1
        }
        
        Write-Host "All distinctValues action tests passed!"

    - name: Test OnlyIfExists Attribute
      shell: pwsh
      run: |
        Write-Host "Testing OnlyIfExists attribute..."
        
        # Create test JSON with some existing and some missing paths
        $testJson = @"
        {
          "ConnectionStrings": {
            "Database": "Server=localhost;Database=Test;"
          },
          "Logging": {
            "LogLevel": {
              "Default": "Information"
            }
          },
          "AppSettings": {
            "Version": "1.0.0"
          }
        }
        "@
        
        $testFile = "test-onlyifexists.json"
        $testJson | Out-File -FilePath $testFile -Encoding UTF8
        
        $data = Get-Content $testFile | ConvertFrom-Json
        
        # Test 1: Verify existing path - ConnectionStrings.Database
        if ($data.ConnectionStrings.Database) {
          Write-Host "✓ ConnectionStrings.Database exists (should be updated with OnlyIfExists=yes)"
        } else {
          Write-Error "✗ ConnectionStrings.Database should exist"
          exit 1
        }
        
        # Test 2: Verify existing path - Logging.LogLevel.Default
        if ($data.Logging.LogLevel.Default) {
          Write-Host "✓ Logging.LogLevel.Default exists (should be updated with OnlyIfExists=yes)"
        } else {
          Write-Error "✗ Logging.LogLevel.Default should exist"
          exit 1
        }
        
        # Test 3: Verify non-existing path - NonExistentSection
        if (-not $data.NonExistentSection) {
          Write-Host "✓ NonExistentSection does not exist (should be skipped with OnlyIfExists=yes)"
        } else {
          Write-Error "✗ NonExistentSection should not exist"
          exit 1
        }
        
        # Test 4: Verify non-existing nested path
        if (-not $data.AppSettings.NonExistentProperty) {
          Write-Host "✓ AppSettings.NonExistentProperty does not exist (should be skipped with OnlyIfExists=yes)"
        } else {
          Write-Error "✗ AppSettings.NonExistentProperty should not exist"
          exit 1
        }
        
        Write-Host "All OnlyIfExists attribute tests passed!"

    - name: Test Multi-Select and Filter Operations
      shell: pwsh
      run: |
        Write-Host "Testing multi-select and filter operations..."
        
        # Create test JSON with multiple matching elements
        $multiSelectJson = @"
        {
          "products": [
            {"name": "Product A", "price": 10.00, "category": "electronics"},
            {"name": "Product B", "price": 25.00, "category": "electronics"},
            {"name": "Product C", "price": 15.00, "category": "books"},
            {"name": "Product D", "price": 30.00, "category": "electronics"}
          ],
          "settings": {
            "timeout": 30,
            "nested": {
              "timeout": 60
            }
          }
        }
        "@
        
        $testFile = "test-multiselect.json"
        $multiSelectJson | Out-File -FilePath $testFile -Encoding UTF8
        
        $data = Get-Content $testFile | ConvertFrom-Json
        
        # Test 1: Verify multiple elements can be selected by category
        $electronicsProducts = $data.products | Where-Object { $_.category -eq "electronics" }
        if ($electronicsProducts.Count -eq 3) {
          Write-Host "✓ Filter by category works (found 3 electronics products)"
        } else {
          Write-Error "✗ Filter by category failed (expected 3, found $($electronicsProducts.Count))"
          exit 1
        }
        
        # Test 2: Verify filter by price range
        $expensiveProducts = $data.products | Where-Object { $_.price -gt 20 }
        if ($expensiveProducts.Count -eq 2) {
          Write-Host "✓ Filter by price range works (found 2 products > 20)"
        } else {
          Write-Error "✗ Filter by price range failed (expected 2, found $($expensiveProducts.Count))"
          exit 1
        }
        
        # Test 3: Verify recursive descent (all timeout values)
        $timeoutCount = 0
        if ($data.settings.timeout) { $timeoutCount++ }
        if ($data.settings.nested.timeout) { $timeoutCount++ }
        
        if ($timeoutCount -eq 2) {
          Write-Host "✓ Recursive descent works (found 2 timeout properties)"
        } else {
          Write-Error "✗ Recursive descent failed (expected 2, found $timeoutCount)"
          exit 1
        }
        
        Write-Host "All multi-select and filter tests passed!"

    - name: Summary
      shell: pwsh
      run: |
        Write-Host ""
        Write-Host "========================================" -ForegroundColor Green
        Write-Host "  Regression Test Summary" -ForegroundColor Green
        Write-Host "========================================" -ForegroundColor Green
        Write-Host "✓ Solution build successful" -ForegroundColor Green
        Write-Host "✓ Test installer built successfully" -ForegroundColor Green
        Write-Host "✓ JSON validation tests passed" -ForegroundColor Green
        Write-Host "✓ Common .NET patterns validated" -ForegroundColor Green
        Write-Host "✓ JSONPath patterns validated" -ForegroundColor Green
        Write-Host "✓ distinctValues action tests passed" -ForegroundColor Green
        Write-Host "✓ OnlyIfExists attribute tests passed" -ForegroundColor Green
        Write-Host "✓ Multi-select and filter tests passed" -ForegroundColor Green
        Write-Host "========================================" -ForegroundColor Green
